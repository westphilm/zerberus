flush ruleset

# -------------------------
# Zentralisierte Konstanten
# -------------------------
define NET_LAN    = 192.168.50.0/24
define NET_WAN    = 192.168.1.0/24
define NET_WG     = 10.6.0.0/24

define IP_PI      = 192.168.1.2
define IP_GW_LAN  = 192.168.50.1

define IF_WAN     = "eth0"
define IF_LAN     = "eth1"
define IF_WG      = "wg0"
define IF_VPN     = "nordlynx"

define MARK_WG    = 0x00000520


table ip filter {
  counter c_dns_fwd_drop        { }
  counter c_dot_client_drop     { }
  counter c_drop_generic        { }
  counter c_fwd_vpn             { }
  counter c_fwd_wan             { }
  counter c_fwd_pi              { }
  counter c_wan_local           { }
  counter c_wan_public          { }
  counter c_dns50               { }
  counter c_dns1                { }
  counter c_dot50               { }
  counter c_dot1                { }

  # ---- zentrale Sets ----
  set CLIENT_NETS {
    type ipv4_addr
    flags interval
    elements = { $NET_WAN, $NET_LAN }
  }

  set DNS_ALLOWED_DST {
    type ipv4_addr
    elements = { $IP_PI, $IP_GW_LAN }
  }

  chain INPUT {
    type filter hook input priority filter; policy accept;

    # DNS requests
    #
    ip saddr $NET_LAN udp dport 53 counter name c_dns50
    ip saddr $NET_LAN tcp dport 53 counter name c_dns50
    ip saddr $NET_WAN udp dport 53 counter name c_dns1
    ip saddr $NET_WAN tcp dport 53 counter name c_dns1

    # DoT requests
    #
    ip saddr $NET_LAN udp dport 853 counter name c_dot50
    ip saddr $NET_LAN tcp dport 853 counter name c_dot50
    ip saddr $NET_WAN udp dport 853 counter name c_dot1
    ip saddr $NET_WAN tcp dport 853 counter name c_dot1


    ## das lassen wir mal offen..
    ## iifname $IF_LAN ip saddr $NET_LAN ip daddr $IP_PI drop

    # DoT #853 wird nicht mehr verwendet
    # iifname $IF_WAN tcp dport 853 ct state established,new accept

    # dnsmasq dhcp eth0 #67
    iifname $IF_WAN udp dport 67 accept
    # dnsmasq dhcp eth1 #67
    iifname $IF_LAN udp dport 67 accept

    iifname $IF_WAN udp dport 51821 accept comment "WireGuard wg0"
    iifname $IF_WG icmp type echo-request accept comment "WG ping -> Pi"

    iifname $IF_WG udp dport 53 accept comment "WG DNS/UDP -> Pi-hole"

    # DoTc#853 via WG wird nicht verwendet..
    ## iifname $IF_WG tcp dport { 53, 853 } accept comment "WG DNS/TCP/DoT -> Pi-hole"
    iifname $IF_WG tcp dport { 53 } accept comment "WG DNS/TCP -> Pi-hole"
  }

  chain OUTPUT {
    type filter hook output priority filter; policy accept;
  }


  chain FORWARD {
    type filter hook forward priority filter; policy drop;

    # eth0-Split (Local vs Internet) – FORWARD, beide Richtungen, nur zählen
    iifname { $IF_LAN, $IF_WG } oifname $IF_WAN ip daddr $NET_WAN counter name c_wan_local
    iifname $IF_WAN            oifname { $IF_LAN, $IF_WG } ip saddr $NET_WAN counter name c_wan_local
    iifname { $IF_LAN, $IF_WG } oifname $IF_WAN ip daddr != $NET_WAN counter name c_wan_public
    iifname $IF_WAN            oifname { $IF_LAN, $IF_WG } ip saddr != $NET_WAN counter name c_wan_public


    ## Pi & Guest Traffic zählen

    # Pi → VPN (hin & zurück)
    #iifname { $IF_WAN,$IF_LAN,$IF_WG } oifname $IF_VPN counter name c_fwd_pi
    #iifname $IF_VPN oifname { $IF_WAN,$IF_LAN,$IF_WG } counter name c_fwd_pi
    iifname { $IF_LAN,$IF_WG,$IF_WAN } oifname $IF_VPN counter name c_fwd_pi
    iifname $IF_VPN oifname { $IF_LAN,$IF_WG,$IF_WAN } counter name c_fwd_pi


    # DROP DNS in FORWARD (Ziel ≠ Pi) -> zählen und blocken, um DNS-Leaks zu verhindern
    iifname { $IF_WAN, $IF_LAN, $IF_WG } tcp dport 53 ip daddr != @DNS_ALLOWED_DST counter name c_dns_fwd_drop drop
    iifname { $IF_WAN, $IF_LAN, $IF_WG } udp dport 53 ip daddr != @DNS_ALLOWED_DST counter name c_dns_fwd_drop drop

    # Kill-Switch: LAN/WG darf nicht ins Internet über eth0 (außer 192.168.1.0/24)
    iifname { $IF_LAN, $IF_WG } oifname $IF_WAN ip daddr != $NET_WAN counter name c_drop_generic drop

    # Pi → WAN direkt (eth0 Internet, 1er-Netz ausgeschlossen) – hin & zurück
    #iifname { $IF_WAN,$IF_LAN,$IF_WG } oifname $IF_WAN ip daddr != $NET_WAN counter name c_fwd_pi
    #iifname $IF_WAN oifname { $IF_WAN,$IF_LAN,$IF_WG } ip saddr != $NET_WAN counter name c_fwd_pi
    iifname { $IF_LAN,$IF_WG } oifname $IF_WAN ip daddr != $NET_WAN counter name c_fwd_pi
    iifname $IF_WAN oifname { $IF_LAN,$IF_WG } ip saddr != $NET_WAN counter name c_fwd_pi

    # wg forward
    iifname $IF_WG  oifname $IF_WAN ct state new,established accept
    iifname $IF_WAN oifname $IF_WG  ct state established,related accept

    # DoT-Clients (TCP/853) -> zählen + DROPPEN
    # unnötig:
    # iifname { $IF_WAN, $IF_LAN } ip saddr @CLIENT_NETS tcp dport 853 counter name c_dot_client_drop drop

    # --- deine erlaubten Pfade (bereinigt) ---
    iifname $IF_LAN oifname $IF_WAN ip saddr $NET_LAN accept
    iifname $IF_WAN oifname $IF_LAN ip daddr $NET_LAN ct state established,related accept

    iifname $IF_WAN oifname $IF_WAN ip saddr $NET_WAN accept
    iifname $IF_WAN oifname $IF_WAN ct state established,related accept

    iifname $IF_WAN oifname $IF_LAN ip saddr $NET_WAN ip daddr $NET_LAN accept
    iifname $IF_LAN oifname $IF_WAN ip saddr $NET_LAN ip daddr $NET_WAN ct state established,related accept

    iifname $IF_WG  oifname $IF_LAN accept comment "WG→LAN"
    iifname $IF_LAN oifname $IF_WG  ct state established,related accept

    iifname $IF_LAN oifname $IF_VPN ip saddr $NET_LAN accept
    iifname $IF_VPN oifname $IF_LAN ct state established,related accept

    iifname $IF_WAN oifname $IF_VPN ip saddr $NET_WAN accept
    iifname $IF_VPN oifname $IF_WAN ct state established,related accept

    iifname $IF_WG  oifname $IF_VPN accept
    iifname $IF_VPN oifname $IF_WG  ct state established,related accept
  }
}

#############################
# Policy Routing Markierung #
#############################
table ip marking {
  chain prerouting_mark {
    type filter hook prerouting priority mangle; policy accept;
    # DoT → novpn
    # DoT wird nicht mehr verwendet
    # iifname $IF_WAN tcp dport 853 meta mark set 0x00000355 comment "DoT → novpn"
    # iifname $IF_WAN tcp dport 853 ct   mark set 0x00000355 comment "DoT → novpn"
    # WG replies markieren
    ct mark $MARK_WG meta mark set ct mark comment "WG reply mark"
    iifname $IF_WG ct   mark set $MARK_WG
    iifname $IF_WG meta mark set $MARK_WG
  }

  # DoT wird nicht mehr verwendet
  # chain output_mark {
  #   type route hook output priority mangle; policy accept;
  #   ip daddr $NET_WG return comment "Bypass mark for WG replies"
  #   ct mark 0x00000355 meta mark set ct mark
  # }

  # Unbound-Anfragen über WAN statt nordlynx:
  #chain output_mark {
  #  type route hook output priority mangle; policy accept;
  #  meta skuid "unbound" meta mark set 0x00000077 comment "Unbound → WAN"
  #}
  # Unbound-Anfragen über nordlynx statt WAN:
  # Falls NordVPN inaktiv: „VPN-down“-Regelsatz routet pref 110 fwmark 0x520 aktuell
  # nach WAN. D. h. Unbound fällt auf WAN zurück (soft-fail).
  #chain output_mark {
  #  type route hook output priority mangle; policy accept;
  #  meta skuid "unbound" counter meta mark set 0x00000520 comment "Unbound → VPN"
  #}
}

# MSS-Clamp (rt-mtu) — bewusst NICHT im Table 'ip mangle', um Telio nicht zu stören
table ip tune {
  chain fwd_mss {
    type filter hook forward priority mangle; policy accept;
    oifname $IF_VPN tcp flags syn / syn,rst tcp option maxseg size set rt mtu
    iifname $IF_WG  tcp flags syn / syn,rst tcp option maxseg size set rt mtu
  }
}

table ip nat {
  counter c_masq_vpn_bytes { }
  counter c_masq_wan_bytes { }
  #counter c_wan_local { }
  #counter c_wan_public { }
  counter c_nat_hits { }

  counter c_masq_wan_public_bytes { }

  chain PREROUTING  { type nat hook prerouting  priority dstnat; policy accept; }
  chain POSTROUTING {
    type nat hook postrouting priority srcnat; policy accept;

    # Gesamt-NAT-Volumen (nur zählen)
    oifname != "lo" counter name c_nat_hits

    # VPN-Masquerade (NordLynx)
    oifname $IF_VPN counter name c_masq_vpn_bytes masquerade

    # WAN-Fallback (eth0) — nur wenn wirklich ins Internet über eth0 gegangen wird
    oifname $IF_WAN counter name c_masq_wan_bytes masquerade

    # WAN Public (Internet) NAT counter – muss bei Kill-Switch 0 bleiben
    oifname $IF_WAN ip daddr != $NET_WAN counter name c_masq_wan_public_bytes masquerade

    # Fallbacks über WAN (gezielt, keine catch-all NAT)
    oifname $IF_WAN ip saddr $NET_LAN masquerade comment "LAN → Internet (Fallback)"
    oifname $IF_WAN ip saddr $NET_WG  masquerade comment "Handy → Internet (Fallback)"
    # NordVPN
    oifname $IF_VPN ip saddr $NET_LAN masquerade comment "LAN → NordVPN"
    oifname $IF_VPN ip saddr $NET_WG  masquerade comment "Handy → NordVPN"
    # neu:
    # 1er Netz -> NordVPN
    # oifname $IF_VPN ip saddr $NET_WAN masquerade comment "1er Netz → NordVPN"
    # 1er Netz -> WAN (Fallback)
    # oifname $IF_WAN ip saddr $NET_WAN masquerade comment "1er Netz → Internet (Fallback)"

    ### Zaehler / Monitoring
    ##

    # Gesamtzähler für NAT (optional)
    # oifname != "lo" counter name c_nat_hits
    # VPN-Masquerade (NordLynx)
    # oifname $IF_VPN counter name c_masq_vpn_bytes masquerade
    # WAN-Fallback (eth0)
    # oifname $IF_WAN counter name c_masq_wan_bytes masquerade
  }
}
